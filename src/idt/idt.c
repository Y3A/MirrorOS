#include "kernel.h"
#include "types.h"
#include "gdt/gdt.h"
#include "idt/idt.h"
#include "io/io.h"
#include "memory/memory.h"
#include "task/scheduler.h"

#include "drivers/vga.h"

IDT_ENTRY idt[TOTAL_INTERRUPTS]; // actual IDT entries the hardware uses
static ISR callbacks[TOTAL_INTERRUPTS]; // our custom callback handlers

// template ISRs generated by asm macro, that calls our custom handlers
extern void *isr_table[TOTAL_INTERRUPTS];

VOID idt_init(VOID)
/*
    * https://wiki.osdev.org/Interrupt_Descriptor_Table#IDTR
    * Initializing IDT Entries and IDT Descriptor, then loading it
*/
{
    IDT_DESC idt_desc;

    unbound_memset(idt, 0, sizeof(idt));
    idt_desc.limit = sizeof(idt)-1;
    idt_desc.base = (DWORD)idt;

    for (INT i = 0; i < TOTAL_INTERRUPTS; i++)
        idt_set(i, isr_table[i]);

    // this is how we bind a custom handler
    idt_register_interrupt_callback(IDT_KEY_PRESS, idt_key_pressed);

    idt_load(&idt_desc);

    return;
}

static VOID idt_key_pressed(PINTERRUPT_FRAME frame)
{
    vga_print("key pressed\n");
    return;
}

VOID idt_load(PIDT_DESC idt_desc_addr)
{
    __asm__
    (
        ".intel_syntax noprefix;"

        "lidt [%0];"

        ".att_syntax;"
        :
        : "r" (idt_desc_addr)
    );

    return;
}

VOID idt_set(INT interrupt_number, PVOID isr_addr)
/*
    * https://wiki.osdev.org/Interrupt_Descriptor_Table#Gate_Descriptor_2
    * Mapping ISRs to an interrupt number to handle it
*/
{
    // isr_addr for address of interrupt service routines
    PIDT_ENTRY entry = &idt[interrupt_number];
    entry->offset_low = (DWORD)isr_addr & 0x0000ffff;
    entry->selector = GDT_KERNEL_CS;
    entry->zero = 0;
    entry->type_attr = 0b11101110;
    entry->offset_high = (DWORD)isr_addr >> 16;

    return;
}

VOID interrupt_handler(DWORD interrupt_no, PINTERRUPT_FRAME frame)
{
    scheduler_load_kernel_segments();
    if (callbacks[interrupt_no]) {
        callbacks[interrupt_no](frame);
        scheduler_update_thread_regs(frame);
    }
    scheduler_load_user_segments();
    
    idt_complete_interrupt_master();
    if (interrupt_no > 0x28)
        // have to acknowledge slave too
        // https://wiki.osdev.org/8259_PIC#End_of_Interrupt
        idt_complete_interrupt_slave();

    return;
}

VOID idt_register_interrupt_callback(DWORD interrupt_no, ISR callback)
{
    callbacks[interrupt_no] = callback;
    return;
}

VOID idt_complete_interrupt_master(VOID)
{
    outsb(PICM_COMMAND, PIC_EOI);
    return;
}

VOID idt_complete_interrupt_slave(VOID)
{
    outsb(PICS_COMMAND, PIC_EOI);
    return;
}